#include <stdio.h>

int cut(int n);

int main()
{
    int N, i, j, item, table[101] = {};
    scanf("%d", &N);

    for (i = 0; i < N; i++)
    {
        scanf("%d", &item);
        table[item] = 1;
    }

    for (i = 1; i < 101; i++)
    {
        if (table[i])
        {
            j = i;
            printf("-输出：j=%d\n", j);
            while (j != 1)
            {
                j = cut(j);
                printf("-输出（cut）：j=%d\n", j);

                // 排除被覆盖的数
                if (j <= 100 && table[j])
                {
                    table[j] = 0;
                    // 一路从 1 到 i 处理过来的，处理过的数（j, j < i），直接跳过
                    if (j < i)
                    {
                        break;
                    }
                }
            }
        }
    }

    int flag = 0;
    for (i = 100; i > 0; i--)
    {
        if (table[i])
        {
            if (flag)
            {
                printf(" ");
            }
            else
            {
                flag = 1;
            }
            printf("%d", i);
        }
    }

    return 0;
}

int cut(int n)
{
    if (n % 2 == 0)
    {
        n = n / 2;
    }
    else
    {
        n = (3 * n + 1) / 2;
    }
    return n;
}

/*
输入：
6
3 5 6 7 8 11

输出：
7 6

解题思路：
- 数据的范围是 [1,100]，因此开辟大小为 101 的整形数组，索引值即是数据值，元素值 0/1 表示数据值是否为“关键数”，初始状态都是“关键数”
- 遍历数组，根据每次 cut 得到的数，即为整形数组的索引值，将其数据值更新为 0，表示被“覆盖”
    - 优化：当 cut 得到的数，小于最外层遍历的索引值时，即可结束 cut，因为遍历是由小到大进行的，小于索引值的 cut 值已经被处理过一遍了
- 最后逆序遍历数组，满足数据值为 1 的索引值，即为最后的一组 “关键数”

遇到的问题：
- 想到定义 struct 和各种数组操作方法，先收集数据值，遍历数组，然后根据 cut 值删除数组中的数据，逻辑太多
- 没有想到处理有限范围数据，看题解才想起，可以采用将「原数据值」抽象为索引值，将数据值抽象为「原数据值」的状态，思路简洁

收获；
- 在解题时，能用简单数据结构抽象表达的，就不定义复杂结构
- 在数据数量、数据值的范围有限的情况下，多思考空间换时间的可能
*/